/**
 * CCTP Message Hash Extractor
 * Extracts the message hash from CCTP burn transaction events
 * 
 * The message hash is generated by keccak256 hashing the message bytes
 * emitted in the MessageSent event from the CCTP TokenMessenger contract.
 */

import { ethers } from 'ethers';
import { logger } from '../utils/logger';

export interface MessageSentEvent {
  message: string; // The raw message bytes (hex string)
}

export class MessageHashExtractor {
  /**
   * Extract message hash from transaction logs/events
   * For Stellar/Soroban, this parses the contract event logs
   * For EVM chains, this parses the MessageSent event
   * 
   * @param txData - Transaction data containing events
   * @returns The keccak256 hash of the message bytes
   */
  extractMessageHash(txData: any): string | null {
    try {
      logger.debug('Extracting message hash from transaction', { txData });

      // Try to find MessageSent event
      const messageSentEvent = this.findMessageSentEvent(txData);
      
      if (!messageSentEvent) {
        logger.warn('No MessageSent event found in transaction');
        return null;
      }

      // Extract message bytes
      const messageBytes = messageSentEvent.message;
      
      // Calculate keccak256 hash
      const messageHash = this.calculateMessageHash(messageBytes);
      
      logger.info('Message hash extracted successfully', { messageHash });
      
      return messageHash;
    } catch (error) {
      logger.error('Failed to extract message hash', error);
      return null;
    }
  }

  /**
   * Calculate the message hash from message bytes using keccak256
   * This is the same hash that Circle's attestation service expects
   * 
   * @param messageBytes - The message bytes (hex string with or without 0x prefix)
   * @returns The keccak256 hash as a hex string (without 0x prefix)
   */
  calculateMessageHash(messageBytes: string): string {
    // Ensure message bytes has 0x prefix
    const hexString = messageBytes.startsWith('0x')
      ? messageBytes
      : '0x' + messageBytes;

    // Calculate keccak256 hash using ethers
    const hash = ethers.keccak256(hexString);

    // Return hash as hex string without 0x prefix (Circle API expects this format)
    return hash.startsWith('0x') ? hash.slice(2) : hash;
  }

  /**
   * Find the MessageSent event in transaction data
   * This needs to be implemented based on the blockchain
   */
  private findMessageSentEvent(txData: any): MessageSentEvent | null {
    try {
      // For Stellar/Soroban transactions
      if (txData.result_meta_xdr || txData.events) {
        return this.extractFromStellarEvents(txData);
      }

      // For EVM-compatible chains
      if (txData.logs) {
        return this.extractFromEVMLogs(txData);
      }

      logger.warn('Unknown transaction data format', { txData });
      return null;
    } catch (error) {
      logger.error('Failed to find MessageSent event', error);
      return null;
    }
  }

  /**
   * Extract MessageSent event from Stellar/Soroban contract events
   */
  private extractFromStellarEvents(txData: any): MessageSentEvent | null {
    try {
      // Parse Soroban contract events
      // The CCTP contract emits a MessageSent event with the message bytes
      
      logger.debug('Parsing Stellar/Soroban events', { txData });
      
      // Parse contract events from transaction result
      // Stellar SDK provides transaction result with contract events
      if (txData.result_meta_xdr) {
        // XDR parsing would be needed here
        // Example structure after parsing:
        // txData.result_meta_xdr -> decode -> events -> find MessageSent
        
        logger.warn('⚠️  Soroban XDR event parsing not yet implemented');
        logger.warn('⚠️  Need to decode result_meta_xdr and extract contract events');
        
        // Real implementation would:
        // const xdr = StellarSdk.xdr.TransactionMeta.fromXDR(txData.result_meta_xdr, 'base64');
        // const events = extractContractEvents(xdr);
        // const messageSentEvent = events.find(e => e.topic.includes('MessageSent'));
        // const messageBytes = messageSentEvent.data.message;
        // return { message: messageBytes };
      }
      
      // Check if events are already parsed (some Stellar SDKs provide this)
      if (txData.events) {
        const messageSentEvent = txData.events.find((e: any) => 
          e.type === 'contract' && 
          (e.topic?.includes('MessageSent') || e.contractId)
        );
        
        if (messageSentEvent && messageSentEvent.value?.message) {
          logger.info('Found MessageSent event in parsed events');
          return { message: messageSentEvent.value.message };
        }
      }
      
      logger.warn('No MessageSent event found in Stellar transaction');
      return null;
    } catch (error) {
      logger.error('Failed to extract from Stellar events', error);
      return null;
    }
  }

  /**
   * Extract MessageSent event from EVM transaction logs
   */
  private extractFromEVMLogs(txData: any): MessageSentEvent | null {
    try {
      // MessageSent event signature
      const MESSAGE_SENT_SIGNATURE = '0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036';
      
      // Find the MessageSent event
      const messageSentLog = txData.logs?.find(
        (log: any) => log.topics?.[0] === MESSAGE_SENT_SIGNATURE
      );

      if (!messageSentLog) {
        return null;
      }

      // Extract message bytes from event data
      // The message is typically in the event data field
      const message = messageSentLog.data;
      
      return { message };
    } catch (error) {
      logger.error('Failed to extract from EVM logs', error);
      return null;
    }
  }

  /**
   * Validate a message hash format
   * Circle expects a 64-character hex string (32 bytes)
   */
  isValidMessageHash(hash: string): boolean {
    // Remove 0x prefix if present
    const cleanHash = hash.startsWith('0x') ? hash.slice(2) : hash;
    
    // Must be 64 hex characters (32 bytes)
    return /^[0-9a-fA-F]{64}$/.test(cleanHash);
  }

  /**
   * Format message hash for Circle API
   * Circle expects the hash without 0x prefix
   */
  formatForCircleAPI(hash: string): string {
    return hash.startsWith('0x') ? hash.slice(2) : hash;
  }
}

export const messageHashExtractor = new MessageHashExtractor();
